<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vanity Mirror Configuration Simulator</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --panel-bg: #ffffff;
            --text-color: #333;
            --accent-color: #0056b3;
            --success-color: #28a745;
            --fail-color: #dc3545;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden; /* Prevent body scroll, handle in canvas/panel */
        }

        h1 { margin: 0 0 10px 0; font-size: 1.2rem; }

        .main-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 1200px;
            width: 100%;
            height: 100%;
        }

        .canvas-container {
            flex: 2;
            position: relative;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #fafafa;
            cursor: crosshair;
        }

        .controls {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .control-group {
            border: 1px solid #eee;
            padding: 15px;
            border-radius: 6px;
        }

        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1rem;
            color: var(--accent-color);
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }

        .input-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        label { font-size: 0.9rem; }
        
        input[type="range"] { flex: 1; margin: 0 10px; }
        span.val { font-family: monospace; font-weight: bold; width: 45px; text-align: right; }

        .status-box {
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2rem;
            margin-bottom: 10px;
            border: 2px solid transparent;
        }
        
        .status-pass { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
        .status-fail { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }

        .legend {
            font-size: 0.8rem;
            margin-top: 10px;
            line-height: 1.5;
        }
        .dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }

        .assumptions {
            font-size: 0.75rem;
            color: #666;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            margin-top: auto;
        }

        button.reset-btn {
            padding: 8px 16px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button.reset-btn:hover { background-color: #004494; }

    </style>
</head>
<body>

    <h1>Mirror Configuration Simulator: "See the Back of Your Head"</h1>

    <div class="main-container">
        <!-- Canvas Area -->
        <div class="canvas-container" id="canvas-wrapper">
            <canvas id="simCanvas"></canvas>
        </div>

        <!-- Controls Area -->
        <div class="controls">
            
            <div id="statusIndicator" class="status-box status-fail">
                FAIL <br><span style="font-size:0.9rem; font-weight:normal">Coverage: 0%</span>
            </div>

            <div class="control-group">
                <h3>Person</h3>
                <div class="input-row">
                    <label>Head Turn (Yaw)</label>
                    <input type="range" id="headYaw" min="-90" max="90" value="0">
                    <span class="val" id="headYawVal">0°</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Left Mirror <span style="font-size:0.7em; color:#666">(Pivot-N-View)</span></h3>
                <div class="input-row">
                    <label>Wall Position (X)</label>
                    <input type="range" id="leftMx" min="0" max="15" step="0.5" value="5">
                    <span class="val" id="leftMxVal">5"</span>
                </div>
                <div class="input-row">
                    <label>Angle</label>
                    <input type="range" id="leftMa" min="10" max="170" value="60">
                    <span class="val" id="leftMaVal">60°</span>
                </div>
                <div style="font-size:0.8rem; color:#666; margin-top:5px;">
                    Specs: 16" Frame, 14" Glass. Pivot on wall.
                </div>
            </div>

            <div class="control-group">
                <h3>Right Mirror <span style="font-size:0.7em; color:#666">(Pivot-N-View)</span></h3>
                <div class="input-row">
                    <label>Wall Position (X)</label>
                    <input type="range" id="rightMx" min="20" max="40" step="0.5" value="32">
                    <span class="val" id="rightMxVal">32"</span>
                </div>
                <div class="input-row">
                    <label>Angle</label>
                    <input type="range" id="rightMa" min="10" max="170" value="120">
                    <span class="val" id="rightMaVal">120°</span>
                </div>
            </div>

            <button class="reset-btn" onclick="resetDefaults()">Reset to Defaults</button>

            <div class="legend">
                <strong>Legend:</strong><br>
                <span class="dot" style="background:green"></span>Valid Ray (Eye → Side → Center → Back)<br>
                <span class="dot" style="background:rgba(255,0,0,0.3)"></span>Blocked/Missed Ray<br>
                <span class="dot" style="background:blue"></span>Central Mirror<br>
                <span class="dot" style="background:#888"></span>Walls
            </div>

            <div class="assumptions">
                <strong>Assumptions:</strong><br>
                1. Top-down view (plan). Height ignored.<br>
                2. Side mirrors pivot at wall anchor point.<br>
                3. Mirror glass centered in frame (1" margin).<br>
                4. Eye position fixed relative to head center.<br>
                5. Goal: Reflection chain Eye > Side > Center > BackHead.
            </div>
        </div>
    </div>

    <script>
        // --- Configuration Constants (Fixed) ---
        const SCALE = 12; // Pixels per inch
        const CANVAS_PADDING = 50;
        
        // Geometry (Inches)
        const DESK_W = 29;
        const DESK_D = 20;
        const CENTRAL_MIRROR_W = 23;
        const CENTRAL_MIRROR_X_OFFSET = 7; // From left short wall
        const LEFT_WALL_L = 11; // Length of short wall extending from back
        
        // Product Specs (Winston Porter)
        const SIDE_MIRROR_TOTAL_W = 16;
        const SIDE_MIRROR_GLASS_W = 14;
        const SIDE_MIRROR_MARGIN = (SIDE_MIRROR_TOTAL_W - SIDE_MIRROR_GLASS_W) / 2;
        
        // Person Model
        const HEAD_RADIUS = 3.5;
        // User is centered relative to central mirror
        const USER_CENTER_X = CENTRAL_MIRROR_X_OFFSET + (CENTRAL_MIRROR_W / 2); 
        const USER_CENTER_Y = 18; // Approx sitting distance from wall
        const EYE_OFFSET_FWD = 2.5; // Eyes are forward of head center
        const TARGET_ARC_ANGLE = 60; // Spread of "back of head" targets (degrees)
        const NUM_TARGET_POINTS = 7;

        // --- State Management ---
        const state = {
            headYaw: 0,
            left: { x: 5, angle: 60 },
            right: { x: 32, angle: 120 }
        };

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        let rect;

        // --- Initialization ---
        function init() {
            // Set canvas size based on wrapper
            const wrapper = document.getElementById('canvas-wrapper');
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            
            addListeners();
            update();
        }

        window.addEventListener('resize', () => {
            const wrapper = document.getElementById('canvas-wrapper');
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            update();
        });

        function addListeners() {
            // Helpers to bind input to state
            const bind = (id, obj, key, suffix='') => {
                const el = document.getElementById(id);
                const valEl = document.getElementById(id + 'Val');
                el.addEventListener('input', (e) => {
                    obj[key] = parseFloat(e.target.value);
                    valEl.innerText = obj[key] + suffix;
                    update();
                });
            };

            bind('headYaw', state, 'headYaw', '°');
            bind('leftMx', state.left, 'x', '"');
            bind('leftMa', state.left, 'angle', '°');
            bind('rightMx', state.right, 'x', '"');
            bind('rightMa', state.right, 'angle', '°');
        }

        function resetDefaults() {
            state.headYaw = 0;
            state.left.x = 5;
            state.left.angle = 60;
            state.right.x = 32;
            state.right.angle = 120;
            
            // Update UI inputs
            document.getElementById('headYaw').value = 0; document.getElementById('headYawVal').innerText = "0°";
            document.getElementById('leftMx').value = 5; document.getElementById('leftMxVal').innerText = '5"';
            document.getElementById('leftMa').value = 60; document.getElementById('leftMaVal').innerText = "60°";
            document.getElementById('rightMx').value = 32; document.getElementById('rightMxVal').innerText = '32"';
            document.getElementById('rightMa').value = 120; document.getElementById('rightMaVal').innerText = "120°";
            
            update();
        }

        // --- Mathematics Helpers ---
        const degToRad = (d) => d * Math.PI / 180;
        
        function rotatePoint(px, py, cx, cy, angleRad) {
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);
            const dx = px - cx;
            const dy = py - cy;
            return {
                x: cx + (dx * cos - dy * sin),
                y: cy + (dx * sin + dy * cos)
            };
        }

        // Line segment intersection
        function getIntersection(p1, p2, p3, p4) {
            const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (d === 0) return null;
            
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / d;
            
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };
            }
            return null;
        }

        // Reflect point P across line segment AB (infinite line logic)
        function reflectPoint(p, a, b) {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / (dx * dx + dy * dy);
            // Closest point on line
            const cx = a.x + t * dx;
            const cy = a.y + t * dy;
            // Reflection
            return {
                x: 2 * cx - p.x,
                y: 2 * cy - p.y
            };
        }

        // --- Simulation Core ---
        function update() {
            // 1. Setup Canvas Transformation
            // Origin (0,0) is back-left corner. We shift canvas to center visible area.
            // Visible area X: -5 to 45. Y: -5 to 30.
            const offsetX = 50;
            const offsetY = canvas.height - 50; // Invert Y axis visually (0 at bottom)

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Transform context to simulation coordinates
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(SCALE, -SCALE); // Y up

            // --- Define Static Geometry ---
            const centralMirror = {
                x1: CENTRAL_MIRROR_X_OFFSET, y1: 0,
                x2: CENTRAL_MIRROR_X_OFFSET + CENTRAL_MIRROR_W, y2: 0
            };

            const leftWall = { x1: 0, y1: 0, x2: 0, y2: LEFT_WALL_L };
            
            // --- Calculate Dynamic Geometry ---
            
            // Left Mirror
            // Pivot at (x, 0). Angle measured from X axis (CCW).
            // Visual check: Angle 90 is sticking out. 0 is along wall right. 180 along wall left.
            // Left mirror usually around 60 deg.
            const lmRad = degToRad(state.left.angle);
            const lmP1 = { x: state.left.x, y: 0 };
            const lmP2 = { 
                x: lmP1.x + Math.cos(lmRad) * SIDE_MIRROR_TOTAL_W, 
                y: lmP1.y + Math.sin(lmRad) * SIDE_MIRROR_TOTAL_W 
            };
            // Glass segment inside frame
            const lmGlass1 = {
                x: lmP1.x + Math.cos(lmRad) * SIDE_MIRROR_MARGIN,
                y: lmP1.y + Math.sin(lmRad) * SIDE_MIRROR_MARGIN
            };
            const lmGlass2 = {
                x: lmP1.x + Math.cos(lmRad) * (SIDE_MIRROR_TOTAL_W - SIDE_MIRROR_MARGIN),
                y: lmP1.y + Math.sin(lmRad) * (SIDE_MIRROR_TOTAL_W - SIDE_MIRROR_MARGIN)
            };

            // Right Mirror
            const rmRad = degToRad(state.right.angle);
            const rmP1 = { x: state.right.x, y: 0 };
            const rmP2 = { 
                x: rmP1.x + Math.cos(rmRad) * SIDE_MIRROR_TOTAL_W, 
                y: rmP1.y + Math.sin(rmRad) * SIDE_MIRROR_TOTAL_W 
            };
            const rmGlass1 = {
                x: rmP1.x + Math.cos(rmRad) * SIDE_MIRROR_MARGIN,
                y: rmP1.y + Math.sin(rmRad) * SIDE_MIRROR_MARGIN
            };
            const rmGlass2 = {
                x: rmP1.x + Math.cos(rmRad) * (SIDE_MIRROR_TOTAL_W - SIDE_MIRROR_MARGIN),
                y: rmP1.y + Math.sin(rmRad) * (SIDE_MIRROR_TOTAL_W - SIDE_MIRROR_MARGIN)
            };

            // Head and Eye
            // Head center
            const hC = { x: USER_CENTER_X, y: USER_CENTER_Y };
            const hYawRad = degToRad(state.headYaw + 90); // +90 because 0 deg usually means facing +X in math, we want +Y (facing mirror)
            
            // Eye position (offset forward from center)
            const eye = {
                x: hC.x + Math.cos(hYawRad) * EYE_OFFSET_FWD,
                y: hC.y + Math.sin(hYawRad) * EYE_OFFSET_FWD
            };

            // Back of Head Targets (Arc opposite to face)
            // Back vector is hYawRad + PI
            const backAngleBase = hYawRad + Math.PI;
            const targets = [];
            const halfArc = degToRad(TARGET_ARC_ANGLE/2);
            for(let i=0; i<NUM_TARGET_POINTS; i++) {
                const t = i / (NUM_TARGET_POINTS - 1); // 0 to 1
                const ang = backAngleBase - halfArc + (t * 2 * halfArc);
                targets.push({
                    x: hC.x + Math.cos(ang) * HEAD_RADIUS,
                    y: hC.y + Math.sin(ang) * HEAD_RADIUS
                });
            }

            // --- Constraint Checks ---
            // Left mirror vs Left Wall
            let lMirrorCollision = false;
            if (getIntersection(lmP1, lmP2, leftWall, {x:0, y:20})) { 
                // Simple check: does segment intersect wall line segment?
                // Actually wall is (0,0) to (0,11). 
                const hit = getIntersection(lmP1, lmP2, {x:0, y:0}, {x:0, y:11});
                if(hit) lMirrorCollision = true;
            }
            // Check if mirror goes behind back wall (y<0)
            if (lmP2.y < 0) lMirrorCollision = true;

            // Right mirror vs Back wall
            let rMirrorCollision = false;
            if (rmP2.y < 0) rMirrorCollision = true;

            // --- Drawing Geometry ---

            // Desktop
            ctx.fillStyle = "#eef";
            ctx.fillRect(USER_CENTER_X - DESK_W/2, 0, DESK_W, DESK_D);
            ctx.strokeStyle = "#ccc";
            ctx.lineWidth = 1/SCALE;
            ctx.strokeRect(USER_CENTER_X - DESK_W/2, 0, DESK_W, DESK_D);

            // Back Wall Line
            ctx.beginPath();
            ctx.moveTo(-10, 0); ctx.lineTo(50, 0);
            ctx.lineWidth = 3/SCALE;
            ctx.strokeStyle = "#555";
            ctx.stroke();

            // Left Wall
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.lineTo(0, LEFT_WALL_L);
            ctx.stroke();

            // Central Mirror
            ctx.beginPath();
            ctx.moveTo(centralMirror.x1, 0); ctx.lineTo(centralMirror.x2, 0);
            ctx.lineWidth = 4/SCALE;
            ctx.strokeStyle = "blue";
            ctx.stroke();

            // Side Mirrors
            function drawMirror(p1, p2, g1, g2, collision) {
                // Frame
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                ctx.lineWidth = 4/SCALE;
                ctx.strokeStyle = collision ? "red" : "#333";
                ctx.stroke();
                // Glass
                ctx.beginPath();
                ctx.moveTo(g1.x, g1.y); ctx.lineTo(g2.x, g2.y);
                ctx.lineWidth = 2/SCALE;
                ctx.strokeStyle = "#aaf";
                ctx.stroke();
                // Pivot dot
                ctx.beginPath();
                ctx.arc(p1.x, p1.y, 0.5, 0, Math.PI*2);
                ctx.fillStyle = "#000";
                ctx.fill();
            }

            drawMirror(lmP1, lmP2, lmGlass1, lmGlass2, lMirrorCollision);
            drawMirror(rmP1, rmP2, rmGlass1, rmGlass2, rMirrorCollision);

            // Head
            ctx.beginPath();
            ctx.arc(hC.x, hC.y, HEAD_RADIUS, 0, Math.PI*2);
            ctx.fillStyle = "#ffd0b0";
            ctx.fill();
            ctx.lineWidth = 1/SCALE;
            ctx.strokeStyle = "#333";
            ctx.stroke();

            // Nose/Face Indicator
            ctx.beginPath();
            ctx.moveTo(hC.x, hC.y);
            ctx.lineTo(hC.x + Math.cos(hYawRad)*(HEAD_RADIUS+1), hC.y + Math.sin(hYawRad)*(HEAD_RADIUS+1));
            ctx.strokeStyle = "rgba(0,0,0,0.2)";
            ctx.stroke();

            // Eyes
            ctx.beginPath();
            ctx.arc(eye.x, eye.y, 0.5, 0, Math.PI*2);
            ctx.fillStyle = "#333";
            ctx.fill();

            // Targets (Back of Head)
            targets.forEach(t => {
                ctx.beginPath();
                ctx.arc(t.x, t.y, 0.2, 0, Math.PI*2);
                ctx.fillStyle = "purple";
                ctx.fill();
            });


            // --- Ray Tracing Logic ---
            
            // We want path: Eye -> SideMirror -> CentralMirror -> Target
            // We use the Image Method for planar reflection calculation.
            // 1. Reflect Targets across Central Mirror (Axis Y=0) -> T_prime
            // 2. Reflect T_prime across Side Mirror Line -> T_double_prime
            // 3. Connect Eye to T_double_prime. 
            // 4. Intersect with Side Mirror? Intersect with Central Mirror?
            
            let successfulRays = 0;

            function checkVisibility(mirrorGlass1, mirrorGlass2, mirrorName) {
                // Plane of side mirror
                const smP1 = mirrorGlass1;
                const smP2 = mirrorGlass2;

                targets.forEach(tgt => {
                    // 1. Reflect Target across Central Mirror (y=0)
                    // Since central mirror is on x-axis, reflection is just (x, -y)
                    const t1 = { x: tgt.x, y: -tgt.y };

                    // 2. Reflect t1 across Side Mirror line
                    const t2 = reflectPoint(t1, smP1, smP2);

                    // 3. Ray from Eye to t2
                    // Does it hit the Side Mirror Segment?
                    const hitSide = getIntersection(eye, t2, smP1, smP2);

                    let success = false;
                    let color = "rgba(255,0,0,0.05)"; // Faint red for fail

                    if (hitSide) {
                        // Ray travels Eye -> hitSide.
                        // From hitSide, it must bounce to t1.
                        // Does the segment hitSide -> t1 hit the Central Mirror Segment?
                        // Central mirror is segment (centralMirror.x1,0) to (centralMirror.x2,0)
                        const hitCentral = getIntersection(hitSide, t1, {x:centralMirror.x1, y:0}, {x:centralMirror.x2, y:0});

                        if (hitCentral) {
                            // Valid geometric path! 
                            // Check for obstruction by head?
                            // Path segments: Eye->hitSide, hitSide->hitCentral, hitCentral->Target
                            // Simple obstruction check: does Eye->hitSide go through head circle?
                            // (Skipping complex circle intersection for simplicity in this file, assume head doesn't block side view if angles are reasonable)
                            
                            success = true;
                            successfulRays++;
                            color = "rgba(0,200,0,0.6)";

                            // Draw successful ray
                            ctx.beginPath();
                            ctx.moveTo(eye.x, eye.y);
                            ctx.lineTo(hitSide.x, hitSide.y);
                            ctx.lineTo(hitCentral.x, hitCentral.y);
                            ctx.lineTo(tgt.x, tgt.y);
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 1/SCALE;
                            ctx.stroke();
                        }
                    }
                    
                    if (!success) {
                        // Draw faint fail line just to show coverage attempt
                        // Only draw a few to avoid clutter? Or just draw faint line to side mirror
                        // ctx.beginPath();
                        // ctx.moveTo(eye.x, eye.y);
                        // ctx.lineTo(smP1.x + (smP2.x-smP1.x)*0.5, smP1.y + (smP2.y-smP1.y)*0.5); // Center of mirror
                        // ctx.strokeStyle = color;
                        // ctx.stroke();
                    }
                });
            }

            // Check Left Mirror
            if (!lMirrorCollision) checkVisibility(lmGlass1, lmGlass2, "left");
            // Check Right Mirror
            if (!rMirrorCollision) checkVisibility(rmGlass1, rmGlass2, "right");

            ctx.restore();

            // --- Update UI Status ---
            const totalTargets = NUM_TARGET_POINTS; // We check both mirrors for same targets. 
            // Logic: If a target is seen by EITHER mirror, it counts. 
            // My loop counted total hits, which might double count if both mirrors see the same point (unlikely with head in way, but possible).
            // For scoring, let's just cap percentage at 100%.
            
            const pct = Math.min(100, Math.round((successfulRays / totalTargets) * 100));
            const statusEl = document.getElementById('statusIndicator');
            
            if (pct > 40) { // Threshold for "working"
                statusEl.className = "status-box status-pass";
                statusEl.innerHTML = `PASS<br><span style="font-size:0.9rem; font-weight:normal">Coverage: ${pct}%</span>`;
            } else {
                statusEl.className = "status-box status-fail";
                statusEl.innerHTML = `FAIL<br><span style="font-size:0.9rem; font-weight:normal">Coverage: ${pct}%</span>`;
            }

            // Warn collisions
            if (lMirrorCollision || rMirrorCollision) {
                statusEl.className = "status-box status-fail";
                statusEl.innerHTML = `INVALID<br><span style="font-size:0.9rem; font-weight:normal">Mirror hits Wall</span>`;
            }
        }

        // Start
        init();

    </script>
</body>
</html>